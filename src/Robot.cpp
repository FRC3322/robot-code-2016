// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<Drivetrain> Robot::drivetrain;
std::shared_ptr<Shooter> Robot::shooter;
std::shared_ptr<Intake> Robot::intake;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    drivetrain.reset(new Drivetrain());
    shooter.reset(new Shooter());
    intake.reset(new Intake());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());
	autonomousCommand.reset(new autonCommand());
	ahrs = RobotMap::ahrs;
	SmartDashboard::PutNumber("front speed",0),SmartDashboard::PutNumber("rear speed",0),
	SmartDashboard::PutNumber("front P",0),SmartDashboard::PutNumber("front I",0),SmartDashboard::PutNumber("front D",0),
	SmartDashboard::PutNumber("rear P",0),SmartDashboard::PutNumber("rear I",0),SmartDashboard::PutNumber("rear D",0);
	SmartDashboard::PutBoolean("testShooterPID",false);
	gearShift(0);
	currentGear=0;

	SmartDashboard::PutNumber("Auton Number: ",0);

	//Talon SRX 15 mode bug
	Robot::drivetrain->EnableSRX();
	Robot::shooter->initShooter();

}

/**
 *
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */

void Robot::DisabledInit(){
	Robot::drivetrain->EnableSRX();
	Robot::shooter->initShooter();

}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Start();
	Robot::drivetrain->EnableSRX();
	Robot::drivetrain->EnableSRX();
	Robot::shooter->initShooter();
}

void Robot::AutonomousPeriodic() {
	Scheduler::GetInstance()->Run();
	Robot::TestNavX();


}

void Robot::gearShift(int position) {
	if (position == 0) {
	RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kForward);
	RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kForward);
	} else {
	RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kReverse);
	RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kReverse);
	}
}
void Robot::autoShift() {
	while(true) {
		maxSpeed = Robot::drivetrain->getVelocity(currentGear);
		if (maxSpeed > shiftHigh && currentGear != 0) {
			gearShift(0);
			currentGear = 0;
		} else if (maxSpeed < shiftLow && currentGear != 1) {
			gearShift(1);
			currentGear = 1;
		}
	}
}

void gathererMove(int target) {
	int move_high = 410;
	int move_low = 102; //target values can be set as desired
	int move_target;
	int kP = .3;
	int kI = 10;
	int kD = 10; //constant values need tuning
	int decay = .5;
	int currentPosition;
	int error;
	int p_term = 0;
	int i_term = 0;
	int d_term = 0;
	int last_error = 0;
	int speed;
	int reached_count = 0;

	if (target == 0) {
		move_target = move_low;
	} else {
		move_target = move_high;
	}
	while(reached_count < 10) {
		currentPosition = Drivetrain::driveSRX1->GetEncPosition(); //change to Talon on gatherer
		error = move_target - currentPosition;
		p_term = error * kP;
		i_term = i_term * decay + error * kI;
		d_term = (error - last_error) * kD;
		speed = p_term + i_term + d_term;
		//set motor to speed
		if (abs(error) < 10) {
			reached_count++;
		} else {
			reached_count = 0;
		}
		last_error = error;
	}
	//stop motor
}

void Robot::checkGatherer() {
	if (button_pressed) {
		gathererMove(button_id) //0 = low, 1 = high
	}
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand.get() != nullptr)
		autonomousCommand->Cancel();
	Robot::drivetrain->EnableSRX();
	Robot::shooter->initShooter();
	autoShift();
//	std::thread autoShiftthread(autoShift);
}

void Robot::TestNavX(){
	SmartDashboard::PutNumber("Angle", RobotMap::ahrs->GetAngle());
	SmartDashboard::PutNumber("Altitude (meters)", RobotMap::ahrs->GetAltitude());
	SmartDashboard::PutNumber("Compass Heading (degrees, 0-360)", RobotMap::ahrs->GetCompassHeading());
	SmartDashboard::PutNumber("Pitch (x axis rotation, -180-180)", RobotMap::ahrs->GetPitch());
	SmartDashboard::PutNumber("Rate (rate of z axis rotation, degrees/second)", RobotMap::ahrs->GetRate());
	SmartDashboard::PutNumber("Temperature (degrees celcius)", RobotMap::ahrs->GetTempC());
	SmartDashboard::PutNumber("Vel X (meters/second, not accurate)", RobotMap::ahrs->GetVelocityX());
	SmartDashboard::PutNumber("Vel Y (meters/second, not accurate)", RobotMap::ahrs->GetVelocityY());
	SmartDashboard::PutNumber("Vel Z (meters/second, not accurate)", RobotMap::ahrs->GetVelocityZ());
	SmartDashboard::PutNumber("Yaw (z axis rotation,-180 to 180)",RobotMap::ahrs->GetYaw());

}

void Robot::TeleopPeriodic() {
	Scheduler::GetInstance()->Run();

	//ahrs (NavX) testing.  Should be disabled / commented out during competitions to reduce overhead
	Robot::TestNavX();

	SmartDashboard::PutNumber("vel",Robot::shooter->returnVel());

	SmartDashboard::PutNumber("amp",Robot::shooter->returnAmpVal());
	SmartDashboard::PutNumber("volts",Robot::shooter->returnVoltVal());

	Robot::drivetrain->getDrive()->ArcadeDrive(Robot::oi->getdriveStick()->GetRawAxis(4),-1*Robot::oi->getdriveStick()->GetY(),true);
	if(Robot::oi->getdriveStick()->GetRawButton(7)){
		Robot::shooter->shootRaw();
	}
	else{
		Robot::shooter->stopShooter();
	}

	if(Robot::oi->getdriveStick()->GetRawButton(1)){
		Robot::intake->takeBallIn();
	}

	//test function for the PID velocity control on the shooter.  Should also be disabled/commented out during competitions, and only used for testing purposes.
	if(SmartDashboard::GetBoolean("testShooterPID",false)){
		Robot::shooter->testPID(SmartDashboard::GetNumber("front speed",0),SmartDashboard::GetNumber("rear speed",0),
								SmartDashboard::GetNumber("front P",0),SmartDashboard::GetNumber("front I",0),SmartDashboard::GetNumber("front D",0),
								SmartDashboard::GetNumber("rear P",0),SmartDashboard::GetNumber("rear I",0),SmartDashboard::GetNumber("rear D",0));
	}


}

void Robot::TestPeriodic() {
	lw->Run();
}

START_ROBOT_CLASS(Robot);

