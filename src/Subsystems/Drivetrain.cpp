// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    driveSRX1 = RobotMap::drivetraindriveSRX1;
    driveSRX2 = RobotMap::drivetraindriveSRX2;
    driveSRX3 = RobotMap::drivetraindriveSRX3;
    driveSRX4 = RobotMap::drivetraindriveSRX4;
    driveTrain = RobotMap::drivetraindriveTrain;
    powerDistPanel = RobotMap::drivetrainpowerDistPanel;
    gearshiftRight = RobotMap::drivetraingearshiftRight;
    gearshiftLeft = RobotMap::drivetraingearshiftLeft;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	const static double kP = 0.05f;
	const static double kI = 0.00f;
	const static double kD = 0.00f;
	const static double kF = 0.00f;

    turnController = new PIDController(kP, kI, kD, kF, RobotMap::ahrs.get(), this);
    turnController->SetInputRange(0.0f,  359.9f);
    turnController->SetOutputRange(-1.0, 1.0);
    turnController->SetContinuous(true);
	LiveWindow::GetInstance()->AddActuator("DriveTrain","Rotation PID Controller",turnController);

}
std::shared_ptr<RobotDrive> Drivetrain::getDrive() {

	return driveTrain;
}


void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void Drivetrain::EnableSRX(){
	Drivetrain::driveSRX1->Enable();
	Drivetrain::driveSRX2->Enable();
	Drivetrain::driveSRX3->Enable();
	Drivetrain::driveSRX4->Enable();

}
float Drivetrain::driveToAngle(float velocity,float setpoint){
//	turnController->SetSetpoint(setpoint);
//	while(!turnController->OnTarget()){
//		driveTrain->ArcadeDrive(0,turnController->Get(),false);
//	}

	const static double kToleranceDegrees = 0.5f;

	this->setpoint = setpoint ;
    turnController->SetAbsoluteTolerance(kToleranceDegrees);
	turnController->SetSetpoint(setpoint);

	rotateToAngleRate = 0;

	turnController->Enable();

	while(!turnController->OnTarget()){
		driveTrain->ArcadeDrive(velocity,rotateToAngleRate,true);
	}

	return RobotMap::ahrs->GetAngle();
}

void Drivetrain::PIDWrite(float output){
	rotateToAngleRate = output;
}

int Drivetrain::getVelocity(int currentGear) { //should output rpm of fastest motor (not drive shaft)
	int fastestSide;
	int encClicksRev = 256;
	int leftSide = driveSRX1->GetEncVel();
	int rightSide = driveSRX2->GetEncVel();
	int speedFactor = currentGear + 1; //assuming the gear ratios are high: 2:1 and low: 1:1
	if (leftSide >= rightSide) {
		fastestSide = leftSide;
	} else {
		fastestSide = rightSide;
	}
	return fastestSide / encClicksRev / speedFactor;
}
