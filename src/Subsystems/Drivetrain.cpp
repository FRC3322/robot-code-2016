// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    driveSRX1 = RobotMap::drivetraindriveSRX1;
    driveSRX2 = RobotMap::drivetraindriveSRX2;
    driveSRX3 = RobotMap::drivetraindriveSRX3;
    driveSRX4 = RobotMap::drivetraindriveSRX4;
    driveTrain = RobotMap::drivetraindriveTrain;


//    powerDistPanel = RobotMap::drivetrainpowerDistPanel;
//    gearshiftRight = RobotMap::drivetraingearshiftRight;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}
std::shared_ptr<RobotDrive> Drivetrain::getDrive() {

	return driveTrain;
}


void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void Drivetrain::EnableSRX(){
	Drivetrain::driveSRX1->Enable();
	Drivetrain::driveSRX2->Enable();
	Drivetrain::driveSRX3->Enable();
	Drivetrain::driveSRX4->Enable();

}

float Drivetrain::driveToAngle(float velocity,float targetAngle){
	double turnAngle = angleToTurn(RobotMap::ahrs->GetYaw(),targetAngle);
	if(RobotMap::ahrs->GetYaw()>0){
		driveTrain->ArcadeDrive(velocity,Drivetrain::calculatePID(targetAngle,-1*sqrt(RobotMap::ahrs->GetYaw()),0.3,.06,0));
	}
	else if(RobotMap::ahrs->GetYaw()<0){
		driveTrain->ArcadeDrive(velocity,Drivetrain::calculatePID(targetAngle,1*sqrt(-RobotMap::ahrs->GetYaw()),0.3,.06,0));
	}
	//	driveTrain->ArcadeDrive(velocity,-kP * turnAngle);
//	driveTrain->ArcadeDrive(.1,0,0);
//	driveTrain->Drive(.3,0);
	return RobotMap::ahrs->GetAngle();
}

void Drivetrain::PIDWrite(float output){

}

double Drivetrain::angleToTurn(double currentAngle, double targetAngle){
	double provisionalAngle = targetAngle-currentAngle;
	if(provisionalAngle>-180 && provisionalAngle<=180){
		return provisionalAngle;
	}
	else if(provisionalAngle>180){
		return provisionalAngle-360;
	}
	else if(provisionalAngle<=-180){
		return provisionalAngle+360;
	}
	//calculation derived from
	//http://math.stackexchange.com/questions/1366869/calculating-rotation-direction-between-two-angles/1366960#1366960
}

int Drivetrain::getVelocity(int currentGear) { //should output rpm of fastest motor (not drive shaft)
	int fastestSide;
	int encClicksRev = 256;
	int leftSide = driveSRX1->GetEncVel();
	int rightSide = driveSRX2->GetEncVel();
	int speedFactor = currentGear + 1; //assuming the gear ratios are high: 2:1 and low: 1:1
	if (leftSide >= rightSide) {
		fastestSide = leftSide;
	} else {
		fastestSide = rightSide;
	}
	return fastestSide / encClicksRev / speedFactor;
}

void Drivetrain::gearShift(int position) {
	if (position == 0) {
		currentGear = 1;
		RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kForward); //assuming kForward is high gear
		RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kForward);
	} else {
		currentGear = 0;
		RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kReverse); //assuming kBackward is low gear
		RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kReverse);
	}
}
void Drivetrain::autoShift() {
		currentSpeed = getVelocity(currentGear);
		if (currentSpeed > shiftHigh && currentGear != 0) {
			gearShift(0);
			currentGear = 0;
		} else if (currentSpeed < shiftLow && currentGear != 1) {
			gearShift(1);
			currentGear = 1;
		}
}
double Drivetrain::calculatePID(double setpoint, double current, double Kp, double Ki, double Kd){
	double encoderAngle = (-285.5-current)*(3.1415/2)/(-182.75);
//	printf("encoder angle %f",encoderAngle);
	f = .4*cos(encoderAngle);

	double dVal = 0;
	Ki = 0.0000;
	double iVal = previousIVal + (double)setpoint-(double)current;
//	printf("IVal %f",iVal);
	if(previous != 0){
		dVal = ((double)current-(double)previous)*Kd;
//		printf("Dval %f",dVal);
	}
	previousIVal = iVal;
	previous = current;
//	return f;

	return (Kp*(setpoint-current) + f)+(iVal*Ki)+-dVal; //there used to be an f term here. maybe that's why its jittery?

}

void Drivetrain::waypointGenerator(){
//	int POINT_LENGTH = 3;
//	Waypoint points[POINT_LENGTH];
//
//	Waypoint p1 = {-4,-1,d2r(45)};  //Waypoint at -4,-1 with an exit angle of 45 degrees being converted into radians
//	Waypoint p2 = {-1,2,0}; //waypoint at -1,2
//	Waypoint p3 = {2,4,0};//waypoint at 2,4
//	points[0] = p1;
//	points[1] = p2;
//	points[2] = p3;
//
//	TrajectoryCandidate candidate;
//
//	// Prepare the Trajectory for Generation.
//	//
//	// Arguments:
//	// Fit Function:        FIT_HERMITE_CUBIC or FIT_HERMITE_QUINTIC
//	// Sample Count:        PATHFINDER_SAMPLES_HIGH (100 000)
//	//                      PATHFINDER_SAMPLES_LOW  (10 000)
//	//                      PATHFINDER_SAMPLES_FAST (1 000)
//	// Time Step:           0.001 Seconds
//	// Max Velocity:        15 m/s
//	// Max Acceleration:    10 m/s/s
//	// Max Jerk:            60 m/s/s/s
//
////	pathfinder_prepare(points,POINT_LENGTH, FIT_HERMITE_CUBIC, PATHFINDER_SAMPLES_HIGH, 0.001,15.0,10.0,60.0, &candidate);
//
//	int length = candidate.length;
//
//	//array of segments (trajectory points) to store the trajectory in
////	Segment *trajectory = malloc(length * sizeof(Segment));
//
//	//Generate the trajectory
//
////	pathfinder_generate(&candidate,trajectory);
}
double Drivetrain::changeMagnitude(float val,float amount){
	if(fabs(val) < amount){
		return 0;
	}
	else if(val>0){
		return val - amount;
	}
	else
		return val + amount;
}
void Drivetrain::newdriveSystem(float f, float t, double yawRate){
	float Kp = 2;
	float Kd = 0; //TODO: make implementation not broken
	float error = (t-(float)yawRate);
	float errorRate = error - previousError;
	const float deadband = .25;
	errorRateArray[i] = errorRate;
	i++;
	if(i>9){
		i = 0;
	}
	if(fabs(f) > .9 && t < .3){
		t = 0;
	}
	float magnitude = sqrt(f*f + t*t);
	if(magnitude < deadband){
		f = 0;
		t = 0;
	}
	f = Drivetrain::changeMagnitude(f,deadband) / (1-deadband);
	t = Drivetrain::changeMagnitude(t,deadband) / (1-deadband);

//	if(fabs(t) < .17){
//		t = 0;
//	}
//	if(fabs(f) < .17){
//		f = 0;
//	}
	previousError = error;
	float avgErrorRate = (errorRateArray[0] + errorRateArray[1] + errorRateArray[2] + errorRateArray[3] + errorRateArray[4])/5;
	//only using 5 of available 10
	float RM = (f+t) + (error * Kp) + (Kd * avgErrorRate);
	float LM = (f-t) - (error * Kp) - (Kd * avgErrorRate);
	LM *=-1;
	SmartDashboard::PutNumber("RM",RM);
	SmartDashboard::PutNumber("LM",LM);
	SmartDashboard::PutNumber("error",error);
	if(fabs(LM)>.0005 || fabs(RM)> .0005){
	float maxVal = std::max(fabs(RM),fabs(LM));
	maxVal = std::max(maxVal,(float)1.0);
		Drivetrain::driveSRX1->Set(RM/maxVal);
		Drivetrain::driveSRX2->Set(RM/maxVal);
		Drivetrain::driveSRX3->Set(LM/maxVal);
		Drivetrain::driveSRX4->Set(LM/maxVal);
	}
	else{
		Drivetrain::driveSRX1->Set(0);
		Drivetrain::driveSRX2->Set(0);
		Drivetrain::driveSRX3->Set(0);
		Drivetrain::driveSRX4->Set(0);
	}
}

