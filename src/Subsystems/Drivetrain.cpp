// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    driveSRX1 = RobotMap::drivetraindriveSRX1;
    driveSRX2 = RobotMap::drivetraindriveSRX2;
    driveSRX3 = RobotMap::drivetraindriveSRX3;
    driveSRX4 = RobotMap::drivetraindriveSRX4;
    driveTrain = RobotMap::drivetraindriveTrain;
//    powerDistPanel = RobotMap::drivetrainpowerDistPanel;
//    gearshiftRight = RobotMap::drivetraingearshiftRight;
//    gearshiftLeft = RobotMap::drivetraingearshiftLeft;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}
std::shared_ptr<RobotDrive> Drivetrain::getDrive() {

	return driveTrain;
}


void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void Drivetrain::EnableSRX(){
	Drivetrain::driveSRX1->Enable();
	Drivetrain::driveSRX2->Enable();
	Drivetrain::driveSRX3->Enable();
	Drivetrain::driveSRX4->Enable();

}

float Drivetrain::driveToAngle(float velocity,float targetAngle){
	double turnAngle = angleToTurn(RobotMap::ahrs->GetAngle(),targetAngle);
	driveTrain->ArcadeDrive(velocity,-kP * turnAngle);
//	driveTrain->ArcadeDrive(.1,0,0);
//	driveTrain->Drive(.3,0);
	return RobotMap::ahrs->GetAngle();
}

void Drivetrain::PIDWrite(float output){

}

double Drivetrain::angleToTurn(double currentAngle, double targetAngle){
	double provisionalAngle = targetAngle-currentAngle;
	if(provisionalAngle>-180 && provisionalAngle<=180){
		return provisionalAngle;
	}
	else if(provisionalAngle>180){
		return provisionalAngle-360;
	}
	else if(provisionalAngle<=-180){
		return provisionalAngle+360;
	}
	//calculation derived from
	//http://math.stackexchange.com/questions/1366869/calculating-rotation-direction-between-two-angles/1366960#1366960
}

int Drivetrain::getVelocity(int currentGear) { //should output rpm of fastest motor (not drive shaft)
	int fastestSide;
	int encClicksRev = 256;
	int leftSide = driveSRX1->GetEncVel();
	int rightSide = driveSRX2->GetEncVel();
	int speedFactor = currentGear + 1; //assuming the gear ratios are high: 2:1 and low: 1:1
	if (leftSide >= rightSide) {
		fastestSide = leftSide;
	} else {
		fastestSide = rightSide;
	}
	return fastestSide / encClicksRev / speedFactor;
}

void Drivetrain::gearShift(int position) {
	if (position == 0) {
	RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kForward);
	RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kForward);
	} else {
	RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kReverse);
	RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kReverse);
	}
}
void Drivetrain::autoShift() {
		maxSpeed = getVelocity(currentGear);
		if (maxSpeed > shiftHigh && currentGear != 0) {
			gearShift(0);
			currentGear = 0;
		} else if (maxSpeed < shiftLow && currentGear != 1) {
			gearShift(1);
			currentGear = 1;
		}
}
