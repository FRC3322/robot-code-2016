// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drivetrain.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Drivetrain::Drivetrain() : Subsystem("Drivetrain") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    driveSRX1 = RobotMap::drivetraindriveSRX1;
    driveSRX2 = RobotMap::drivetraindriveSRX2;
    driveSRX3 = RobotMap::drivetraindriveSRX3;
    driveSRX4 = RobotMap::drivetraindriveSRX4;
    driveTrain = RobotMap::drivetraindriveTrain;

//    powerDistPanel = RobotMap::drivetrainpowerDistPanel;
//    gearshiftRight = RobotMap::drivetraingearshiftRight;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

}
std::shared_ptr<RobotDrive> Drivetrain::getDrive() {

	return driveTrain;
}


void Drivetrain::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void Drivetrain::EnableSRX(){
	Drivetrain::driveSRX1->Enable();
	Drivetrain::driveSRX2->Enable();
	Drivetrain::driveSRX3->Enable();
	Drivetrain::driveSRX4->Enable();

}

float Drivetrain::driveToAngle(float velocity,float targetAngle){
	double turnAngle = angleToTurn(RobotMap::ahrs->GetYaw(),targetAngle);
	if(RobotMap::ahrs->GetYaw()>0){
		driveTrain->ArcadeDrive(velocity,Drivetrain::calculatePID(targetAngle,-1*sqrt(RobotMap::ahrs->GetYaw()),0.3,.06,0));
	}
	else if(RobotMap::ahrs->GetYaw()<0){
		driveTrain->ArcadeDrive(velocity,Drivetrain::calculatePID(targetAngle,1*sqrt(-RobotMap::ahrs->GetYaw()),0.3,.06,0));
	}
	//	driveTrain->ArcadeDrive(velocity,-kP * turnAngle);
//	driveTrain->ArcadeDrive(.1,0,0);
//	driveTrain->Drive(.3,0);
	return RobotMap::ahrs->GetAngle();
}

void Drivetrain::PIDWrite(float output){

}

double Drivetrain::angleToTurn(double currentAngle, double targetAngle){
	double provisionalAngle = targetAngle-currentAngle;
	if(provisionalAngle>-180 && provisionalAngle<=180){
		return provisionalAngle;
	}
	else if(provisionalAngle>180){
		return provisionalAngle-360;
	}
	else if(provisionalAngle<=-180){
		return provisionalAngle+360;
	}
	//calculation derived from
	//http://math.stackexchange.com/questions/1366869/calculating-rotation-direction-between-two-angles/1366960#1366960
}

int Drivetrain::getVelocity(int currentGear) { //should output rpm of fastest motor (not drive shaft)
	int fastestSide;
	int encClicksRev = 256;
	int leftSide = driveSRX1->GetEncVel();
	int rightSide = driveSRX2->GetEncVel();
	int speedFactor = currentGear + 1; //assuming the gear ratios are high: 2:1 and low: 1:1
	if (leftSide >= rightSide) {
		fastestSide = leftSide;
	} else {
		fastestSide = rightSide;
	}
	return fastestSide / encClicksRev / speedFactor;
}

void Drivetrain::gearShift(int position) {
	if (position == 0) {
		currentGear = 1;
		RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kForward); //assuming kForward is high gear
		RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kForward);
	} else {
		currentGear = 0;
		RobotMap::drivetraingearshiftLeft->Set(DoubleSolenoid::kReverse); //assuming kBackward is low gear
		RobotMap::drivetraingearshiftRight->Set(DoubleSolenoid::kReverse);
	}
}
void Drivetrain::autoShift() {
		currentSpeed = getVelocity(currentGear);
		if (currentSpeed > shiftHigh && currentGear != 0) {
			gearShift(0);
			currentGear = 0;
		} else if (currentSpeed < shiftLow && currentGear != 1) {
			gearShift(1);
			currentGear = 1;
		}
}
double Drivetrain::calculatePID(double setpoint, double current, double Kp, double Ki, double Kd){
	double encoderAngle = (-285.5-current)*(3.1415/2)/(-182.75);
//	printf("encoder angle %f",encoderAngle);
	f = .4*cos(encoderAngle);

	double dVal = 0;
	Ki = 0.0000;
	double iVal = previousIVal + (double)setpoint-(double)current;
//	printf("IVal %f",iVal);
	if(previous != 0){
		dVal = ((double)current-(double)previous)*Kd;
//		printf("Dval %f",dVal);
	}
	previousIVal = iVal;
	previous = current;
//	return f;

	return (Kp*(setpoint-current) + f)+(iVal*Ki)+-dVal; //there used to be an f term here. maybe that's why its jittery?

}

void Drivetrain::waypointGenerator(){
	int POINT_LENGTH = 3;
	Waypoint points[POINT_LENGTH];

	Waypoint p1 = {-4,-1,d2r(45)};  //Waypoint at -4,-1 with an exit angle of 45 degrees being converted into radians
	Waypoint p2 = {-1,2,0}; //waypoint at -1,2
	Waypoint p3 = {2,4,0};//waypoint at 2,4
	points[0] = p1;
	points[1] = p2;
	points[2] = p3;

	TrajectoryCandidate candidate;

	// Prepare the Trajectory for Generation.
	//
	// Arguments:
	// Fit Function:        FIT_HERMITE_CUBIC or FIT_HERMITE_QUINTIC
	// Sample Count:        PATHFINDER_SAMPLES_HIGH (100 000)
	//                      PATHFINDER_SAMPLES_LOW  (10 000)
	//                      PATHFINDER_SAMPLES_FAST (1 000)
	// Time Step:           0.001 Seconds
	// Max Velocity:        15 m/s
	// Max Acceleration:    10 m/s/s
	// Max Jerk:            60 m/s/s/s

	pathfinder_prepare(points,POINT_LENGTH, FIT_HERMITE_CUBIC, PATHFINDER_SAMPLES_HIGH, 0.001,15.0,10.0,60.0, &candidate);

	int length = candidate.length;

	//array of segments (trajectory points) to store the trajectory in
	Segment *trajectory = malloc(length * sizeof(Segment));

	//Generate the trajectory

	pathfinder_generate(&candidate,trajectory);
}
